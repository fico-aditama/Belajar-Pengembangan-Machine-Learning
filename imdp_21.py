# -*- coding: utf-8 -*-
"""IMDP_21.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wf3e4KF7Lset6ntQ2X8rvFj-1GHLIyHD
"""

#@title **Proyek Akhir : Image Classification Model Deployment**
Nama = 'Fiko Aditama' #@param
Email = 'fikoaditama114@gmail.com' #@param

# Commented out IPython magic to ensure Python compatibility.
!pip install split-folders tqdm
!pip install -q -U plot_keras_history
!pip install -q -U kaggle

!sudo apt -q install tree

import os
import tensorflow as tf
import splitfolders
import numpy as np  
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import warnings
warnings.filterwarnings('ignore')

from google.colab import files,drive
from keras.preprocessing import image
from plot_keras_history import plot_history
from tensorflow.keras.optimizers import Adam,SGD
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Activation, Dense, Flatten,Dropout

print(tf.__version__) #cek versi tensorflow

# upload json kaggle
files.upload()
!mkdir ~/.kaggle
!mv ./kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d karakaggle/kaggle-cat-vs-dog-dataset -p /content/cat_vs_dog/ --unzip
print(os.listdir('/content/cat_vs_dog/'))
!rm /content/cat_vs_dog/kaggle-cat-vs-dog-dataset.zip
!tree -d /content/cat_vs_dog/

base_dir  = "/content/cat_vs_dog/kagglecatsanddogs_3367a/PetImages/"

# membuat direktori rock,paper dan scissors pada direktori data training
dir_cat  = os.path.join(base_dir, 'Cat')
dir_dog = os.path.join(base_dir, 'Dog')

#cek struktur hierarki folder
!tree -d /content/cat_vs_dog/kagglecatsanddogs_3367a/PetImages/

print(f"Total file Cat :\
 {(len(os.listdir(dir_cat)))}")

print(f"Total file Dog :\
 {(len(os.listdir(dir_dog)))}")

#Augmentasi Gambar
train_datagen = ImageDataGenerator(
                    rescale=1./255,
                    rotation_range=30,
                    horizontal_flip=True,
                    shear_range = 0.2,
                    zoom_range=0.2,
                    fill_mode = 'nearest',
                    validation_split = 0.2) 
test_datagen = ImageDataGenerator(
                    rescale=1./255,
                    rotation_range=30,
                    horizontal_flip=False,
                    shear_range = 0.2,
                    fill_mode = 'nearest',
                    validation_split = 0.2)

#Image Generator
train_generator = train_datagen.flow_from_directory(
        base_dir, 
        target_size=(150, 150), 
        batch_size=16,
        class_mode='categorical',
        color_mode='rgb',
        shuffle=False,
        subset='training'
        )
 
validation_generator = test_datagen.flow_from_directory(
        base_dir, # direktori data validasi
        target_size=(150, 150), 
        batch_size=16,
        class_mode='categorical',
        color_mode='rgb',
        shuffle=False,
        subset='validation'
        )

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(64, (6,6), strides = (1,1), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(pool_size = (2,2), padding = 'valid'),
    tf.keras.layers.Conv2D(128, (6,6), strides = (1,1), activation='relu'),
    tf.keras.layers.MaxPooling2D(pool_size = (2,2), padding = 'valid'),
    tf.keras.layers.Conv2D(256, (6,6), strides = (1,1), activation='relu'),
    tf.keras.layers.MaxPooling2D(pool_size = (2,2), padding = 'valid'),
    tf.keras.layers.Conv2D(256, (6,6), strides = (1,1), activation='relu'),
    tf.keras.layers.MaxPooling2D(pool_size = (2,2), padding = 'valid'),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(2, activation='softmax')
])
model.compile(loss='binary_crossentropy',
              optimizer=tf.optimizers.Adam(lr=0.00146),
              metrics=['accuracy'])

model.summary()

def scheduler(epoch, lr):
  if epoch < 5:
    return lr
  else:
    return lr * tf.math.exp(-0.1)

lr_schedule = tf.keras.callbacks.LearningRateScheduler(scheduler, verbose=1)
tb_callback = tf.keras.callbacks.TensorBoard(
    log_dir='logs', histogram_freq=0, write_graph=True, write_images=False,
    update_freq='epoch', embeddings_freq=0,
    embeddings_metadata=None
)

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy') > 0.99 and logs.get('val_accuracy') > 0.99):
      print("\nAkurasi telah lebih dari 90%!")
      self.model.stop_training = False   
callbacks = myCallback()

# latih model dengan model.fit 
with tf.device('/device:GPU:0'):
  history = model.fit(
         train_generator,
         steps_per_epoch=19968//512,  
         epochs=10, 
         validation_data=validation_generator,
         validation_steps=4991//512,
         verbose=1,shuffle=False,
         callbacks =[callbacks,lr_schedule, tb_callback]
         )

plot_history(history)
plt.show()

file_up = files.upload()
 
def predict_pic(files):
  for file in file_up.keys():
  # predicting images
    img = image.load_img(file, target_size=(150,150))
    imgplot = plt.imshow(img)
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)

    images = np.vstack([x])
    classes = model.predict(images, batch_size=1000)
  print(file)
  if classes[0,0] == 1:
    print("It's Dog")
  else:
    print("It's Cat")
predict_pic(file_up)

converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

with open('RPS_model.tflite', 'wb') as f:
  f.write(tflite_model)